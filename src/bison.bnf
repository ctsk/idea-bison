{
    tokens=[
        ID = "regexp:[.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]([.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]|[-0-9])*"
        BRACKETED_ID = "regexp:\[[.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]([.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]|[-0-9])*\]"
        space = "regexp:\s+"
        PROLOGUE = "regexp:%\{+%}"
        CHAR_LITERAL = "regexp:'.+'"
        STRING ="regexp:\".+\""
        BRACED_CODE="regexp:\{.+}"
        comment = "regexp:/\*.+\*\/"
        PERCENT_PERCENT="regexp:%%"
    ]
    elementTypeClass="info.fluffos.BisonCompositeElementType"
    tokenTypeClass="info.fluffos.BisonTokenType"
}

input    ::= prologue_declaration* PERCENT_PERCENT rules_or_grammar_declaration+ epilogue_opt
prologue_declaration ::= PROLOGUE
           | grammar_declaration
           | '%<flag>'
           | '%define' variable value
           | '%header' string_opt
           | '%error-verbose'
           | ( '%expect' | '%expect-rr' ) INT_LITERAL
           | ( '%file-prefix' | '%language' | '%name-prefix' | '%output' | '%require' | '%skeleton' ) STRING
           | '%glr-parser'
           | '%initial-action' BRACED_CODE
           | '%no-lines'
           | '%nondeterministic-parser'
           | '%param' '{...}'+
           | '%pure-parser'
           | '%token-table'
           | '%verbose'
           | '%yacc'
           | error? ';'
grammar_declaration
         ::= symbol_declaration
           | '%start' symbols_1
           | code_props_type '{...}' generic_symlist_item+
           | '%default-prec'
           | '%no-default-prec'
           | ( '%code' ID_OR_CHAR_LITERAL? | '%union' union_name ) '{...}'
code_props_type
         ::= '%destructor'
           | '%printer'
union_name
         ::= ID_OR_CHAR_LITERAL?
symbol_declaration
         ::= '%nterm' nterm_decls
           | '%token' token_decls
           | '%type' TAG? symbols_1 ( TAG symbols_1 )*
           | precedence_declarator TAG? token_decl_for_prec_1 ( TAG token_decl_for_prec_1 )*
precedence_declarator
         ::= '%left'
           | '%right'
           | '%nonassoc'
           | '%precedence'
string_opt
         ::= STRING?
tag_opt  ::= TAG?
generic_symlist_item
         ::= symbol
           | TAG
TAG      ::= '<*>'
           | '<>'
nterm_decls
         ::= token_decls
token_decls
         ::= TAG? token_decl_1 ( TAG token_decl_1 )*
token_decl_1
         ::= token_decl+
token_decl
         ::= ID_OR_CHAR_LITERAL int_opt alias
int_opt  ::= INT_LITERAL?
alias    ::= ( string_as_id | TSTRING )?
token_decl_for_prec_1
         ::= token_decl_for_prec+
token_decl_for_prec
         ::= ID_OR_CHAR_LITERAL int_opt
           | string_as_id
symbols_1
         ::= symbol+
rules_or_grammar_declaration
         ::= rules
           | ( grammar_declaration | error ) ';'
rules    ::= ID named_ref_opt ':' rhs ( '|' rhs | ';' )*
rhs      ::= ( ( symbol | tag_opt BRACED_CODE ) named_ref_opt | '%?{...}' | '%empty' | '%prec' symbol | ( '%dprec' | '%expect' | '%expect-rr' ) INT_LITERAL | '%merge' TAG )*
named_ref_opt ::= BRACKETED_ID?
variable ::= ID_OR_CHAR_LITERAL
value    ::= ( ID_OR_CHAR_LITERAL | STRING | BRACED_CODE )?
ID_OR_CHAR_LITERAL ::= ID | CHAR_LITERAL

symbol   ::= ID_OR_CHAR_LITERAL
           | string_as_id
string_as_id
         ::= STRING
epilogue_opt
         ::= '%%' EPILOGUE?