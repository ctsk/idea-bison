package generated.lexer;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;

import static com.intellij.psi.TokenType.BAD_CHARACTER;
import static com.intellij.psi.TokenType.WHITE_SPACE;
import static generated.GeneratedTypes.*;

%%

%{
  public generated.lexer._BisonLexer() {
    this((java.io.Reader)null);
  }
%}

%public
%class generated.lexer._BisonLexer
%implements FlexLexer
%function advance
%type IElementType
%unicode

EOL=\R
WHITE_SPACE=\s

letter=[.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
id=        {letter}({letter}|[-0-9])*
int=       [0-9]+
xint=      0[xX][0-9abcdefABCDEF]+
eol=       \n|\r\n

 /* UTF-8 Encoded Unicode Code Point, from Flex's documentation. */
mbchar=    [\x09\x0A\x0D\x20-\x7E]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF]([\x80-\xBF]{2})|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x\90-\xBF]([\x80-\xBF]{2})|[\xF1-\xF3]([\x80-\xBF]{3})|\xF4[\x80-\x8F]([\x80-\xBF]{2})

/* main character classes */
LineTerminator = \r|\n|\r\n
InputCharacter = [^\r\n]

WhiteSpace = {LineTerminator} | [ \t\f]+

/* comments */
Comment = {TraditionalComment} | {EndOfLineComment}

TraditionalComment = "/*" [^*] ~"*/" | "/*" "*"+ "/"
EndOfLineComment = "//" {InputCharacter}* {LineTerminator}?

 /* A C-like comment in directives/rules. */
%x SC_YACC_COMMENT
 /* Characters and strings in directives/rules. */
%x SC_ESCAPED_CHARACTER SC_ESCAPED_STRING SC_ESCAPED_TSTRING
 /* A identifier was just read in directives/rules.  Special state
    to capture the sequence 'identifier :'. */
%x SC_AFTER_IDENTIFIER

 /* POSIX says that a tag must be both an id and a C union member, but
    historically almost any character is allowed in a tag.  We
    disallow NUL, as this simplifies our implementation.  We match
    angle brackets in nested pairs: several languages use them for
    generics/template types.  */
%x SC_TAG

 /* Four types of user code:
    - prologue (code between '%{' '%}' in the first section, before %%);
    - actions, printers, union, etc, (between braced in the middle section);
    - epilogue (everything after the second %%).
    - predicate (code between '%?{' and '{' in middle section); */
%x SC_PROLOGUE SC_BRACED_CODE SC_EPILOGUE SC_PREDICATE
 /* C and C++ comments in code. */
%x SC_COMMENT SC_LINE_COMMENT
 /* Strings and characters in code. */
%x SC_STRING SC_CHARACTER
 /* Bracketed identifiers support. */
%x SC_BRACKETED_ID SC_RETURN_BRACKETED_ID

%%


  /*-----------------------.
  | Scanning white space.  |
  `-----------------------*/

<YYINITIAL,SC_AFTER_IDENTIFIER,SC_BRACKETED_ID,SC_RETURN_BRACKETED_ID>
{
  /* Comments and white space.  */
  "," { }
  [ \f\t\v\r]|{eol}  |
  "//".*       { continue; }
  "/*" { yybegin(SC_YACC_COMMENT); }
}

<YYINITIAL> {
  "%"{id} { return ERROR; }


  {Comment}                         {return COMMENT; }
  {WHITE_SPACE}                     { return WHITE_SPACE; }

  {id}                              { return ID; }
  {int}                             { return INT_LITERAL; }
  {xint}                            { return INT_LITERAL; }

  {int}{id} { return ERROR; }
 /* Characters.  */
  "'"         {yybegin(SC_ESCAPED_CHARACTER);}

  /* Strings. */
  "\""        {yybegin(SC_ESCAPED_STRING);}
  "_(\""      {yybegin(SC_ESCAPED_TSTRING);}

 /* Prologue. */
  "%{"       {yybegin(SC_PROLOGUE);  }
  "{" { yybegin(SC_BRACED_CODE); }
}



<SC_PROLOGUE>
{
  "%}"      { yybegin(YYINITIAL); return PROLOGUE;}
  <<EOF>>   { return ERROR; }
}

  /*----------------------------------------------------------.
  | Scanning a Bison character literal, decoding its escapes. |
  | The initial quote is already eaten.                       |
  `----------------------------------------------------------*/

<SC_ESCAPED_CHARACTER>
{
  "'" { yybegin(YYINITIAL); return CHAR_LITERAL; }
  {eol}  {return ERROR;}
  <<EOF>>   {return ERROR;}
}

<SC_EPILOGUE>
{
  <<EOF>> {yybegin(YYINITIAL); return EPILOGUE;}
}

<SC_COMMENT,SC_LINE_COMMENT,SC_BRACED_CODE,SC_PREDICATE,SC_PROLOGUE,SC_EPILOGUE,SC_STRING,SC_CHARACTER,SC_ESCAPED_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_TSTRING>
{
  /* Accept multibyte characters in one block instead of byte after
     byte, so that add_column_width and mbsnwidth can compute correct
     screen width.
     Add a fallthrough "|." so that non UTF-8 input is still accepted
     and does not jam the scanner.  */
  {mbchar}|.   {}
}


[^] { return BAD_CHARACTER; }
